#################################################################################
# Licensed to the .NET Foundation under one or more agreements.                 #
# The .NET Foundation licenses this file to you under the MIT license.          #
# See the LICENSE file in the project root for more information.                #
#################################################################################

# This job processes code coverage reports generated during test runs,
# merges them, generates code coverage reports, publishes them to the
# pipeline, and uploads them to CodeCov.

parameters:

  # True to include debug steps.
  - name: debug
    type: boolean
    default: false

  # The pool image to use.
  - name: image
    type: string

  # The agent pool name.
  - name: pool
    type: string

  # Array of target frameworks to process code coverage for:
  #
  #   e.g. [net462, net8.0, net9.0]
  #
  - name: targetFrameworks
    type: object

  # True to upload code coverage results to CodeCov.
  - name: upload
    type: boolean

jobs:
  - job: CodeCoverage
    displayName: Publish Code Coverage

    pool:
      name: ${{ parameters.pool }}
      ${{ if eq(parameters.pool, 'Azure Pipelines') }}:
        vmImage: ${{ parameters.image }}
      ${{ else }}:
        demands:
        - imageOverride -equals ${{ parameters.image }}

    variables:
      # Use a temp directory that is cleaned up after each job runs.  This helps
      # avoid disk space issues on pooled agents that may run many jobs before
      # being retired.
      - name: workingDir
        value: $(Agent.TempDirectory)/coverage

    steps:

      - ${{if eq(parameters.debug, true)}}:
        - pwsh: Get-Volume
          displayName: '[Debug] Show Disk Usage'

        - pwsh: 'Get-ChildItem env: | Sort-Object Name'
          displayName: '[Debug] List Environment Variables'

      # Install the .NET SDK.
      - template: /eng/pipelines/steps/install-dotnet.yml@self
        parameters:
          debug: ${{ parameters.debug }}

      # Install additional dotnet tools.
      - pwsh: |
          dotnet tool install --global dotnet-coverage
          dotnet tool install --global dotnet-reportgenerator-globaltool
        displayName: Install dotnet tools

      # Download all of the coverage reports from the test jobs.
      #
      # These artifacts contain the .coverage files generated during test runs,
      # along with a bunch of other files that we ignore.
      #
      - task: DownloadPipelineArtifact@2
        displayName: Download Coverage Reports
        inputs:
          # All of our coverage report artifact names start with 'net'.
          itemPattern: '**\net*'
          targetPath: $(workingDir)/originals

      - ${{if eq(parameters.debug, true)}}:
        - pwsh: Get-Volume
          displayName: '[Debug] Show Disk Usage'

        - pwsh: Get-ChildItem "$(workingDir)/originals" -Recurse -File -Filter *.coverage
          displayName: '[Debug] List coverage files'

      # Merge them all into a single XML file.
      - pwsh: >-
          dotnet-coverage merge "$(workingDir)/originals/**/*.coverage"
          --output "$(workingDir)/coverage.xml"
          --output-format xml
          --log-file "$(workingDir)/merge.log"
          --log-level Verbose
        displayName: Merge coverage files to XML

      - ${{if eq(parameters.debug, true)}}:
        - pwsh: Get-Volume
          displayName: '[Debug] Show Disk Usage'

      # Convert the merged XML file into Cobertura reports for publishing, one
      # per package (MDS, AKV, etc).
      - pwsh: >-
          reportgenerator
          "-reports:$(workingDir)/coverage.xml"
          "-targetdir:$(workingDir)/cobertura/mds"
          -reporttypes:Cobertura
          "-assemblyfilters:+microsoft.data.sqlclient.dll"
          "-sourcedirs:$(Build.SourcesDirectory)/src/Microsoft.Data.SqlClient/src"
          "-classfilters:+Microsoft.Data.*"
        displayName: '[MDS] Convert to Cobertura format'

      - pwsh: >-
          reportgenerator
          "-reports:$(workingDir)/coverage.xml"
          "-targetdir:$(workingDir)/cobertura/akv"
          -reporttypes:Cobertura
          "-assemblyfilters:+microsoft.data.sqlclient.alwaysencrypted.azurekeyvaultprovider.dll"
          "-sourcedirs:$(Build.SourcesDirectory)/src/Microsoft.Data.SqlClient/add-ons/AzureKeyVaultProvider"
          "-classfilters:+Microsoft.Data.*"
        displayName: '[AKV] Convert to Cobertura format'

      - ${{if eq(parameters.debug, true)}}:
        - pwsh: Get-Volume
          displayName: '[Debug] Show Disk Usage'

      # Publish the Cobertura reports to the pipeline.
      - task: PublishCodeCoverageResults@2
        displayName: Publish code coverage results
        inputs:
          summaryFileLocation: $(workingDir)/cobertura/**/Cobertura.xml

      # Publish the Cobertura reports to CodeCov, if desired.
      - ${{if eq(parameters.upload, true)}}:
        # Download the CodeCov CLI
        - pwsh: |
            $ProgressPreference = 'SilentlyContinue'
            Invoke-WebRequest -Uri https://cli.codecov.io/latest/windows/codecov.exe -Outfile $(workingDir)/codecov.exe
          displayName: Download CodeCov CLI

        # We upload MDS and AKV reports separately so that CodeCov can show
        # them as separate entries in its UI.

        # Upload the MDS report.
        - pwsh: >-
            $(workingDir)/codecov
            --verbose
            upload-process
            --fail-on-error
            -t $(CODECOV_TOKEN)
            --disable-search
            -f "$(workingDir)/cobertura/mds/Cobertura.xml"
            -F MDS
          displayName: '[MDS] Upload to CodeCov'

        # Upload the AKV report.
        - pwsh: >-
            $(workingDir)/codecov
            --verbose
            upload-process
             --fail-on-error
            -t $(CODECOV_TOKEN)
            --disable-search
            -f "$(workingDir)/cobertura/akv/Cobertura.xml"
            -F AKV
          displayName: '[AKV] Upload to CodeCov'
