################################################################################
# Licensed to the .NET Foundation under one or more agreements.  The .NET
# Foundation licenses this file to you under the MIT license.  See the LICENSE
# file in the project root for more information.
################################################################################

# This job packs the Azure package into NuGet and symbols packages and publishes
# them as a named pipeline artifact.
#
# This template defines a job named 'pack_azure_package_job' that can be
# depended on by downstream jobs.

parameters:

  # The name of the Abstractions pipeline artifacts to download.
  #
  # This is used when the referenceType is 'Package'.
  - name: abstractionsArtifactsName
    type: string
    default: Abstractions.Artifacts

  # The Abstractions package verion to depend on.
  #
  # This is used when the referenceType is 'Package'.
  - name: abstractionsPackageVersion
    type: string

  # The name of the pipeline artifacts to publish.
  - name: azureArtifactsName
    type: string
    default: Azure.Artifacts

  # The assembly file version to stamp into the Azure DLLs.
  - name: azureAssemblyFileVersion
    type: string
    default: ''

  # The version to apply to the NuGet package and DLLs.
  - name: azurePackageVersion
    type: string

  # The type of build to test (Release or Debug)
  - name: buildConfiguration
    type: string
    values:
    - Release
    - Debug

  # True to enable extra debug steps and logging.
  - name: debug
    type: boolean
    default: false

  # The list of upstream jobs to depend on.
  - name: dependsOn
    type: object
    default: []

  # The verbosity level for the dotnet CLI commands.
  - name: dotnetVerbosity
    type: string
    default: normal
    values:
    - quiet
    - minimal
    - normal
    - detailed
    - diagnostic

  # The reference type to use:
  #
  # Project - dependent projects are referenced directly.
  # Package - dependent projects are referenced via NuGet packages.
  #
  - name: referenceType
    type: string
    values:
    - Package
    - Project

jobs:

  - job: pack_azure_package_job
    displayName: 'Pack Azure Package'

    dependsOn: ${{ parameters.dependsOn }}

    pool:
      name: Azure Pipelines
      vmImage: ubuntu-latest

    variables:

      # The Azure project file to use for all dotnet CLI commands.
      - name: project
        value: src/Microsoft.Data.SqlClient.Extensions/Azure/src/Azure.csproj

      # The directory where the NuGet packages will be staged before being
      # published as pipeline artifacts.
      - name: dotnetPackagesDir
        value: $(Build.StagingDirectory)/dotnetPackages

      # dotnet CLI arguments common to all commands.
      - name: commonArguments
        value: >-
          --verbosity ${{ parameters.dotnetVerbosity }}
          -p:ReferenceType=${{ parameters.referenceType }}
          -p:AbstractionsPackageVersion=${{ parameters.abstractionsPackageVersion }}

      # dotnet CLI arguments for build/test/pack commands
      - name: buildArguments
        value: >-
          $(commonArguments)
          --configuration ${{ parameters.buildConfiguration }}
          -p:AzurePackageVersion=${{ parameters.azurePackageVersion }}
          -p:AzureAssemblyFileVersion=${{ parameters.azureAssemblyFileVersion }}

      # Explicitly unset the $PLATFORM environment variable that is set by the
      # 'ADO Build properties' Library in the ADO SqlClientDrivers public
      # project.  This is defined with a non-standard Platform of 'AnyCPU', and
      # will fail the builds if left defined.  The stress tests solution does
      # not require any specific Platform, and so its solution file doesn't
      # support any non-standard platforms.
      #
      # Note that Azure Pipelines will inject this variable as PLATFORM into the
      # environment of all tasks in this job.
      #
      # See:
      #   https://learn.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&tabs=yaml%2Cbatch
      #
      - name: Platform
        value: ''

      # Do the same for $CONFIGURATION since we explicitly set it using our
      # 'buildConfiguration' parameter, and we don't want the environment to
      # override us.
      - name: Configuration
        value: ''

    steps:

      # Emit environment variables if debug is enabled.
      - ${{ if eq(parameters.debug, true) }}:
        - pwsh: 'Get-ChildItem Env: | Sort-Object Name'
          displayName: '[Debug] Print Environment Variables'

      # For Package reference builds, we must first download the Abstractions package artifacts.
      - ${{ if eq(parameters.referenceType, 'Package') }}:
        - task: DownloadPipelineArtifact@2
          displayName: Download Abstractions Package Artifacts
          inputs:
            artifactName: ${{ parameters.abstractionsArtifactsName }}
            targetPath: $(Build.SourcesDirectory)/packages

      # Install the .NET SDK.
      - template: /eng/pipelines/steps/install-dotnet.yml@self
        parameters:
          debug: ${{ parameters.debug }}

      # We use the 'custom' command because the DotNetCoreCLI@2 task doesn't
      # support all of our argument combinations for the different build steps.

      # Restore the project.
      - task: DotNetCoreCLI@2
        displayName: Restore Project
        inputs:
          command: custom
          custom: restore
          projects: $(project)
          arguments: $(commonArguments)

      # Build the project.
      - task: DotNetCoreCLI@2
        displayName: Build Project
        inputs:
          command: custom
          custom: build
          projects: $(project)
          arguments: $(buildArguments) --no-restore

      # Create the NuGet packages.
      - task: DotNetCoreCLI@2
        displayName: Create NuGet Package
        inputs:
          command: custom
          custom: pack
          projects: $(project)
          arguments: $(buildArguments) --no-build -o $(dotnetPackagesDir)

      # Publish the NuGet packages as a named pipeline artifact.
      - task: PublishPipelineArtifact@1
        displayName: Publish Pipeline Artifact
        inputs:
          targetPath: $(dotnetPackagesDir)
          artifactName: ${{ parameters.azureArtifactsName }}
          publishLocation: pipeline
